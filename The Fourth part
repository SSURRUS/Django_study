#编写一个简单的表单
更新一下投票详情页的模板，包含一个HTML<form>元素：
'''
<form action="{% url 'polls:vote' question.id %}" method="post">
{% csrf_token %}
<fieldset>
    <legend><h1>{{ question.question_text }}</h1></legend>
    {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}
    {% for choice in question.choice_set.all %}
        <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
        <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
    {% endfor %}
</fieldset>
<input type="submit" value="Vote">
</form>
'''
说明：
1、上面的模板在Question的每个Choice前添加一个单选按钮。每个单选按钮的value属性是对应各个Choice的ID。每个单选按钮的
name是"choice"。这意味着，当有人选择一个单选按钮并提交表单提交时，它将发送一个POST数据choice=#，其中#为选择的choice
的ID。这是HTML表单的基本概念。
2、我们将表单的action设置为{% url 'polls:vote' question.id %},并设置method="post"。使用method="post"(而不是method="get")
是非常重要的，因为提交这个表单的行为将改变服务器端的数据。当你创建一个改变服务器端数据的表单时，使用method="post"。这是一种优秀的
网站开发技巧。
3、forloop.counter指示for标签已经循环了多少次
4、由于我们创建了一个POST表单（具有修改数据的功能），需要小心跨站点请求伪造。Django自带一个防御系统。
简而言之，针对内部URL的POST表单都应该使用 {% csrf_token %} 模板标签。

创建一个Django视图来处理提交的数据。为  投票应用创建一个URLconf，包括：
'''
path("<int:question_id>/vote/", views.vote, name="vote"),
'''
还创建了一个vote()函数的虚拟实现。将下面的代码添加到polls/views.py
'''
from django.db.models import F
from django.http import HttpResponse,HttpResponseRedirect
from django.shortcuts import get_object_or_404,render
from django.urls import reverse

from .modles import Choice,Question

def vote(request,question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        return render(
            request,
            "polls/detail.html",
            {
                "question": question,
                "error_message":"You didn't select a choice.",
            }
        )
    else:
        selected_choice.votes = F("votes") + 1
        selected_choice.save()
        #始终在成功处理 POST 数据后返回一个 HttpResponseRedirect。这可以防止用户点击“返回”按钮时数据被重复提交。
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))

'''
注意：
1、request.POST是一个类字典对象，让你可以通过关键字的名字获取提交的数据。这个例子中，request.POST['choice']以字符
串形式返回选择的Choice的ID。request.POST的值永远是字符串
注意，Django还以同样的方式提供request.GET用于访问GET数据--但我们在代码中显式地使用request.POST,以保证数据只能通过
POST调用改动。
2、如果在request.POST['choice']数据中没有提供choice，POST将引发一个KeyError。上面的代码检查KeyError，如果没有给出choice
将重新显示Question表单和一个错误信息。
3、F("votes") + 1 指示数据库 将投票数增加 1。
4、在增加Choice的得票数之后，代码会返回一个HttpResponseRedirect而不是常用的HttpResponse。HttpResponseRedirect只接收一个参数：
用户将要被重定向的URL
在成功处理POST数据后，应该总是返回一个HttpResponseRedirect。
5、我们在HttpResponseRedirect的构造函数中使用了reverse（）函数。这个函数避免了我们在视图函数中硬编码URL。需要我们给出我们想要
跳转的视图的名字和该视图所对应的URL模式中需要给该视图提供的参数。 reverse() 调用将返回一个这样的字符串：
'''
"/polls/3/results/"
'''
其中3是question.id的值。重定向的URL将调用"resuls"视图来显示最终的页面
request是一个HttpRequest对象。
当有人对Question()进行投票后，vote()视图将请求重定向到Question的结果界面。
'''
from django.shortcuts import get_object_or_404,render

def results(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request,'polls/results/html',{"question":question})
'''
这边和detail()视图几乎一模一样。唯一不同的是模板的名字。
创建一个polls/results.html模板
'''
<h1>{{ question.question_text }}</h1>

<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
{% endfor %}
</ul>

<a href="{% url 'polls:detail' question.id %}">Vote again?</a>
'''
这时候在浏览器访问/polls/1/然后为Question投票。能看到一个投票界面，每次投票之后都会更新。
提交时没有选择任何Choice，可以看到错误信息。

#使用通用视图
detail()和result()视图都很精简--并且，像上面提到的那样，存在冗余问题。显示投票列表的index（）
视图也有类似性。

这些视图反映基本的网络开发中的一个常见情况：根据URL的参数从数据库中获取数据、载入模板然后返回渲染
后的模板。针对这种情况，Django提供了一种快捷方式，叫做“通用视图”

通用视图将常见的模式抽象到了一个地步，以至于你甚至不需要编写Python代码来创建一个应用程序。例如，
ListView和DetailView通用视图分别抽象了“显示对象列表”和“显示特定类型对象的详细界面”的概念

把投票应用转换为通用视图系统，需要完成如下几步：
1、转换URLconf
2、删除一些旧的、不再需要的视图
3、基于Django的通用视图引入新的视图

#改良URLconf
首先打开polls/urls.py并把它修改成：
'''
from django.urls import path

from . import views

app_name = "polls"
urlpatterns = [
    path("", views.IndexView.as_view(), name="index"),
    path("<int:pk>/", views.DetailView.as_view(), name="detail"),
    path("<int:pk>/results/", views.ResultsView.as_view(), name="results"),
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
'''
第二和第三个模式的路径字符串中匹配的模式名称已从 <question_id> 更改为 <pk>。这是因
为我们将使用 DetailView 通用视图来替换我们的 detail() 和 results() 视图，它期望从 URL 
中捕获的主键值被称为 "pk"。

#改良视图
我们将删除旧的index,detail和results视图，并用Django的通用视图代替。打开polls/views.py文件，
并把它修改成：
'''
from django.db.models import F
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404,render
from django.urls import reverse
from django.views import generic

from .models import Choice,Question

class IndexView(generic.ListView):
    template_name = "polls/index.html"
    context_object_name = "latest_question_list"

    def get_queryset(self):
        return Question.objects.order_by("-pub_date")[:5]

class DetailView(generic.DetailView):
    model = Question
    template_name = "polls/detail.html"
class ResultsView(generic.DetailView):
    model = Question
    template_name = "polls/results.html"

    def vote(self, request, question_id):
'''
每个通用视图都需要知道他将要操作的模型。可以使用model属性来提供这个信息（在这个实例中，
对于DetailView和ResultsView，是model=Question），或者定义get_queryset(）方法来实现

默认情况下，通用视图DetailView使用一个叫做<app name>/<model name>_detail.html的模板。
在我们的代码中，它将使用"polls/question_detail.html" 模板。template_name属性是用来告诉
Django使用一个指定的模板名字，而不是自动生成的默认名字。我们也为results列表视图指定了
template_name--这确保results视图和detail视图在渲染时具有不同的外观，即使它们在后台都是同一个
DetailView。

类似地，ListView使用了一个叫做<app:name>/<model name>_list.html的默认模板；我们使用template_name
来告诉ListView使用我们创建的已经存在的"polls/index.html"模板

在之前的教程中，提供模板文件时都带有一个包含 question 和 latest_question_list 变量的 context。对于 DetailView ，
question 变量会自动提供—— 因为我们使用 Django 的模型（Question）， Django 能够为 context 变量决定一个合适的名字。
然而对于 ListView， 自动生成的 context 变量是 question_list。为了覆盖这个行为，我们提供 context_object_name 属性，
表示我们想使用 latest_question_list。作为一种替换方案，你可以改变你的模板来匹配新的 context 变量 —— 这是一种更便捷
的方法，告诉 Django 使用你想使用的变量名。
