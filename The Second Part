#数据库配置
打开misite/setting.py 这里面包含了Django项目设置的python版块

通常，这个配置文件使用SQLite作为默认数据库。
想使用其他的数据库，需要安装合适的database bindings，然后改变设置文件中
DATABASES'default' 项目中的一些键值：

ENGINE  —可选值有
'django.db.backends.sqlite3','django.db.backends.postgresql',
'django.db.backends.mysql',或者'django.db.backends.oracle'其他可用后端

NAME-数据库的名称。如果使用SQLite,数据库将是电脑上的一个文件，在这种情况下，NAME应该是此文件完整的
绝对路径，包括文件名。默认BASE_DIR/'db.sqlite3'将把数据库文件存储在项目的根目录中

如果不使用SQLite，则必须添加一些额外的设置，比如USER、PASSWORD、HOST等等

编辑mysite/setting.py文件前，先设置TIME_ZONE为你的时区
关注一下文件头部的INSTALLED_APPS设置项。这里包括会在你项目中启动的所有Django应用。
应用能在多个项目中使用，可以打包并且发布，让别人使用这个项目。
通常，INSTALLED_APPS默认包括了以下Django的自带应用：
django.contrib.admin--管理员站点
django.contrib.auth--认证授权系统
django.contrib.contenttypes--内容类型框架
django.contrib.session--会话框架
django.contrib.messages--消息框架
django.contrib.staticfiles--管理静态文件的框架
这些应用被默认启用是为了给常规项目提供方便

默认开启的某些应用至少需要一个数据表，所以在使用他们之前需要在数据库中创建一些表
'''
$python manage.py migrate
'''
这个migrate命令查看INSTALLED_APPS配置，并根据mysite/settings.py文件中的数据库配置和随应用提供的数据库迁移
文件，创建必要的数据库表。会看到它应用的每一个迁移都有一个消息。
运行你的数据库的命令行客户端，输入\dt(PostareSQL),
SHOW TABLES;(MariaDB,MySQL),.tables(SQLite)或SELECT TABLE_NAME FROM USER_TABLES;(Oeacle)来显示Django创建的表

#创建模型
在Django里写一个数据库驱动的Web应用第一步是定义模型

例如在这个投票应用中，需要创建两个模型：问题Question和选项Choice。Question模型包括问题描述和发布时间。Choice模型有两个
字段，选项描述和当前得票数。每个选项属于一个问题。
'''
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
'''
每个模型被表示为django.db.models.Model类的子类。每个模型有许多类变量，他们都表示为模型里的一个数据库字段。

每个字段都是Field类的实例-比如，字符字段被表示为CharField，日期时间字段被表示为DateTimeField，这将告诉Django
每个字段要处理的数据字段。

每个Field类实例变量的名字（例如question_text和pub_date）也是字段名，所以最好使用对机器友好的格式。

可以使用可选的选项来为Field定义一个人类可读的名字。这个功能在很多Django内部组成部分都被使用了。
如果某个字段没有提供此名称，Django将会使用对机器友好的名称，也就是变量名。

定义某些Field类实例需要参数。例如CharField需要一个max_length参数。这个参数不仅仅用来定义数据库结构，
也可以用来定义数据。

Field也能够接收多个可选参数；上述例子可以看到：votes的默认值default设为0

我们使用ForeignKey定义一个关系。告诉Django，每个Choice对象都关联到一个Question对象。
Django支持的数据库关系包括一对一，多对多，多对一。

#激活模型
上面的一小段用于创建模型的代码给了Django很多信息，通过这些信息Django可以：
1、为这个应用创建数据库schema(生成CREATE TABLE语句)
2、创建可以与Question和Choice对象进行交互的Python数据库API

首先得把polls应用安装到我们的项目中

为了在我们的工程中包含这个应用，我们需要在配置类INSTALLED_APPS中添加设置。因为PollsConfig类写在文件
polls/apps.py中，所以它的路径是'polls.apps.PollConfig'。在文件mysite/setting.py中INSTALLED_APP子
项添加点式路径后，它看起来像：
'''
INSTALLED_APPS = [
    "polls.apps.PollsConfig",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
'''
现在Django项目会包含polls应用
'''
$ python manage.py makemigrations polls
'''
将会看到如下输出：
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Question
    - Create model Choice
通过运行makegiration命令，Django会检测你对模型文件的修改（在这种情况下，你已经取得新的），并且把修改的部分储存为
一次迁移

迁移是Django对于模型定义的变化的存储形式-其实也只是磁盘上的一些文件。

Django有一个自动执行数据库迁移并同步管理你的数据库结构的命令-这个命令是migrate。
看看迁移命令会执行哪些SQL语句。sqlmigrate命令接收一个迁移的名称，然后返回SQL：
'''
$python manage.py sqlmigrate polls 0001
'''
会看到类似如下的输出
'''
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" bigint NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
'''
注意：
1、输出的内容和你使用的数据库有关，上面输出的示例使用的是PostgreSQL
2、数据库的表名是由应用名（polls）和模型名的小写形式（question和choice）连接而来
3、主键（IDs）会被自动创建
4、默认的，Django会在外键字段名后追加字符串"_id"
5、外键关系由FOREIGN KEY生成。不用关心DEFERRABLE部分，它只是告诉PostgreSQL，请在事务
全部执行完再创建外键关系
6、是为你正在使用的数据库定制的，因此特定于数据库的字段类型 例如“auto_increment”（MySQL）、
“bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY”（PostgreSQL）或“integer primary
key autoincrement” `` (SQLite) 会自动为您处理。 字段名称的引用也是如此——例如，使用双引号或单引号。
7、这个sqlmigrate命令并没有真正在你的数据库中的执行迁移。它只是将命令输出到屏幕上，让你看看Django
认为需要执行哪些SQL语句。

也可以试着运行python manage.py check 这个命令帮助你检查项目中的问题，并且检查过程中不会对数据库
进行任何操作

再次运行migrate命令，在数据库里创建新定义的模型和数据表：
'''
$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Rendering model states... DONE
  Applying polls.0001_initial... OK
'''
这个migrate命令选中所有还没有执行过的迁移（Django通过在数据库中创建一个特殊的表django_migrations来跟踪执行过那些迁移）
并应用到数据库上-也就是将你对模型的更改同步到数据库结构上。

迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表-专注于使数据库平滑升级
而不会丢失数据。改变模型只需要三步
1、编辑models.py文件，改变模型
2、运行python manage.py makemigrations为模型的改变生成迁移文件
3、运行python manage.py migrate来应用数据库迁移
数据库迁移被分解成生成和应用两个命令是为了在代码控制系统上提交迁移数据并使其能在多个应用里使用；这不仅仅会让开发更加简单
，也给别的开发和生产环境中的使用带来方便。

#初试API
进入交互式的Python命令行，通过以下命令打开Python命令行
'''
$python manage.py shell
'''
我们使用这个命令不是简单的使用"python"是因为manage.py会设置DJANGO_SETTINGS_MODULE环境变量，
这个变量会让Django根据mysie/settings.py文件来设置Python包的导入路径

一旦你进入了shell，就可以探索数据库API：
'''
>>> from polls.models import Choice, Question  # Import the model classes we just wrote.

# No questions are in the system yet.
>>> Question.objects.all()
<QuerySet []>

# Create a new Question.
# Support for time zones is enabled in the default settings file, so
# Django expects a datetime with tzinfo for pub_date. Use timezone.now()
# instead of datetime.datetime.now() and it will do the right thing.
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())

# Save the object into the database. You have to call save() explicitly.
>>> q.save()

# Now it has an ID.
>>> q.id
1

# Access model field values via Python attributes.
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=datetime.timezone.utc)

# Change values by changing the attributes, then calling save().
>>> q.question_text = "What's up?"
>>> q.save()

# objects.all() displays all the questions in the database.
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>]>
'''
<Question: Question object (1)> 对于我们了解这个对象的细节没什么帮助。通过编辑Question模型的
代码来修复这个问题。给Question和Choice增加__str()__方法。
'''
from django.db import models

class Question(models.Model):
    def __str__(self):
         return self.question_text
class Choice(models.Model):
    def __str__(self):
        return self.choice_text
'''
给模型增加__str()__()方法是很重要的，这不仅仅能给你在命令行里的使用带来方便，Django自动生成的admin
里也使用这个方法来表示对象。

给这个模型再添加一个自定义方法：
'''
import datetime

from django.db import models
from django.utils import timezone

class Question(models.Model):
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
'''
新加入的import datetime和from django.utils import timezone分别导入Python标准的datetime模板和Django中和
时区相关的django.utils.timezone工具模块。

保存这些更改并再次运行python manage.py shell 以启动新的Python交互式shell:
'''
>>> from polls.models import Choice, Question

#确保我们添加的 __str__() 方法正常工作。
Question.objects.all()
<QuerySet [<Question: What's up?>]>

# Django 提供了一个功能丰富的数据库查询 API，完全由关键字参数驱动。
>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith="What")
<QuerySet [<Question: What's up?>]>

# Get the question that was published this year.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

# 请求一个不存在的 ID，这将引发异常。
>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# Lookup by a primary key is the most common case, so Django provides a
# shortcut for primary-key exact lookups.
# The following is identical to Question.objects.get(id=1).
>>> Question.objects.get(pk=1)
<Question: What's up?>

# Make sure our custom method worked.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# Give the Question a couple of Choices. The create call constructs a new
# Choice object, does the INSERT statement, adds the choice to the set
# of available choices and returns the new Choice object. Django creates
# a set (defined as "choice_set") to hold the "other side" of a ForeignKey
# relation (e.g. a question's choice) which can be accessed via the API.
>>> q = Question.objects.get(pk=1)

# Display any choices from the related object set -- none so far.
>>> q.choice_set.all()
<QuerySet []>

# Create three choices.
>>> q.choice_set.create(choice_text="Not much", votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text="The sky", votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text="Just hacking again", votes=0)

# Choice objects have API access to their related Question objects.
>>> c.question
<Question: What's up?>

# And vice versa: Question objects get access to Choice objects.
>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

# The API automatically follows relationships as far as you need.
# Use double underscores to separate relationships.
# This works as many levels deep as you want; there's no limit.
# Find all Choices for any question whose pub_date is in this year
# (reusing the 'current_year' variable we created above).
>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

# Let's delete one of the choices. Use delete() for that.
>>> c = q.choice_set.filter(choice_text__startswith="Just hacking")
>>> c.delete()
'''
#了解Django管理界面
创建管理员账号
首先，我们需要创建一个能登录管理页面的用户。
'''
$python manage.py createsuperuser
'''
键入你想使用的用户名，然后按下回车键:
Username:admin
提示输入你想要使用的邮箱地址：
Email address: admin@example.com
最后一步是输入密码（二次验证）：
Password: **********
Password (again): *********
Superuser created successfully

#启动开发服务器
Django的管理界面就是启动的。启动开发服务器
如果开发服务器未启动 用如下命令启动它：
'''
$python manage.py runserver
'''
打开浏览器，转到本地域名 “/admin/” 目录， -- 比如 http://127.0.0.1:8000/admin/ 。应该会看见管理员登录界面：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin01.png
这边翻译功能是默认开启的，如果设置了LANGUAGE_CODE，登陆界面将显示你设置的语言（如果Django有相应的翻译）

#进入管理站点页面
试着使用上一步中创建的超级用户来登录。会看到Django管理页面的索引页：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin02.png
将会看到几种可编辑的内容：组和用户。这个是由django.contrib.auth提供的

#向管理界面中加入投票应用
需要再做一件事：告诉管理，问题Question对象需要一个后台接口。打开polls/admin.py,并编辑
'''
  from django.contrib import amin

 from .models import Question

 admin.site.register(Question)
'''

#体验便捷的管理功能
现在向管理界面注册了问题Question类。Django知道它应该被显示在索引页：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin03t.png
https://docs.djangoproject.com/zh-hans/5.0/_images/admin03t.png
点击Questions。现在看到问题是"Questions"对象的列表"charge list"。这个页面会显示所有数据库里的问题Question对象，
可以选择这个点来进行修改。这里现在有我们上一部分创建的“What's up?”问题
https://docs.djangoproject.com/zh-hans/5.0/_images/admin04t.png
点击“What's up?”来编辑这个问题（Question）对象：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin05t.png
注意：
1、这个表单是从问题Question模型中自动生成的
2、不同的字段类型会生成对应的HTML输入控件。每个类型的字段都知道它们该如何在管理页面显示自己
3、每个日期时间字段DateTimeField都有JavaScript写的快捷按钮。日期有转到今天的快捷按钮和一个弹出式日历界面。
时间有设为现在（Now）的快捷按钮和一个列出常用时间的弹出式列表
页面的底部提供了几个选项：
保存：保存改变然后返回对象列表
保存并继续编辑：保存改变，然后重新载入当前对象的修改界面
保存并新增：保存改变，然后添加一个新的空对象并载入界面
删除：显示一个确认删除的界面

通过点击 “今天(Today)” 和 “现在(Now)” 按钮改变 “发布日期(Date Published)”。然后点击 “保存并继续编辑(Save and add another)”
按钮。然后点击右上角的 “历史(History)”按钮。你会看到一个列出了所有通过 Django 管理页面对当前对象进行的改变的页面，其中列出了时
间戳和进行修改操作的用户名：

https://docs.djangoproject.com/zh-hans/5.0/_images/admin06t.png
