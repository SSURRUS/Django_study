#自定义后台表单
通过admin.site.register(Question)注册Question模型，Django能够构建一个默认
的表单用于展示。如若期望能自定义表单的外观和工作方式。可以在注册模型的时候将
这些设置告诉Django。

通过重新排列表单上的字段来看看工作形式。用以下内容替换admin.site.register(Question)：
'''
from django.contrib import admin
from .models import Question

class QuestionAdmin(admin.ModelAdmin):
    fields = ["pub_date","question_text00"]

admin.site.register(Question,QuestionAdmin)
'''
需要遵循以下流程--创建一个模型后台类，接着其作为第二个参数传递给admin.site.register()--
在需要修改模型的后台管理选项的时候可以这么做。
以上修改使得“Publication date”字段显示在“Question”字段之前":
https://docs.djangoproject.com/zh-hans/5.0/_images/admin07.png
只有两个字段的时候看起来没什么用，但是如果拥有数十个表单的话，为表单选择一个合适的排列方式
就显得很细节了。
'''
from django.contrib import admin
from .models import Question

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None, {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date']}),
    ]
'''
fieldsets元组中的第一个元素是字段表的标题。下面是表单现在的样子：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin08t.png
https://docs.djangoproject.com/zh-hans/5.0/_images/admin08t.png

#添加关联的对象
有了投票的后台页。一个Question有多个Choice，但是后台页却没有显示多个选项。
有两个方法可以解决这个问题。第一是仿照我们向后台注册Question一样注册Choice:
'''
from django.contrib import admin

from .models import Choice, Question

# ...
admin.site.register(Choice)
'''
现在“Choice”在Django后台页中是一个可用的选项了。“添加选项”的表单看起来像这样：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin09.png
在这个表单中，"Question"字段是一个包含在数据库中所有投票的选择框。Django知道要将
ForeignKey在后台中以选择框<select>的形式展示。此时，需要一个投票。  

注意"问题"旁边的"添加另一个问题"链接。每个与另一个具有'ForeignKey'关系的对象都可以
免费获得此链接。当你点击“添加另一个问题”时，会看到一个带有“添加问题”表单的弹出窗口。
如果在该窗口添加问题并点击“保存”,Django会将问题保存到数据库中，并将其动态添加为你
正在查看的“添加选项”表单上的选定选项。

移除调用register()注册Choice模型的代码。随后像这样修改Question的注册代码：
'''
from django.contrib import admin
from .models import Choice,Question

class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3


class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None, {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date'],"classes": ["collapse"]}),
    ]
    inlines = [ChoiceInline]

    admin.site.register(Question, QuestionAdmin)
'''
这会告诉Django："Choice"对象要在Question后台页面编辑。默认提供3个足够的选项字段。
加载"添加投票"页面来看看他长啥样：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin10t.png
它看起来像这样：有三个关联的选项插槽--由extra定义，且每次你返回任意已创建的对象的“修改”页面时，会见到三个新的插槽。
在三个插槽的末端，你会看到一个“添加新选项”的按钮。如果你单击它，一个新的插槽会被添加。如果你想移除已有的插槽，可以
点击插槽右上角的X。以下展示了一个已经添加的插槽：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin14t.png
不过，仍然有点小问题。它占据了大量的屏幕区域来显示所有关联的Choice对象的字段。对于这个问题，Django提供了一种表格式
的单行显示关联对象的方法。要使用它，只需要按如下的形式修改ChoiceInline申明：
'''
class ChoiceInline(admin.TabularInline): ...
'''
通过TabularInline(替代StackedInline),关联对象以一种表格式的方式展示，显得更加紧凑：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin11t.png
有一个额外的“删除？”列，允许删除使用“添加另一个选项”按钮添加的行和已保存的行

#自定义后台更改列表
现在投票的后台看起来还行，我们对“更改列表”页面进行一些调整--改成一个能展示系统中所有投票的页面
以下是它此时的外观：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin04t.png
默认情况下，Django显示每个对象的str()。但有时如果我们能显示单个字段会更有帮助。为此，应该使用
list_display admin选项，该选项是要在对象的更改列表页上以列的形式显示的字段名称列表：
'''
class QuestionAdmin(admin.ModelAdmin):
    # ...
    list_display = ["question_text", "pub_date"]
'''
另外，把was_published_recently() 方法也加上：
'''
class QuestionAdmin(admin.ModelAdmin):
    # ...
    list_display = ["question_text", "pub_date", "was_published_recently"]
'''
现在修改投票的列表页看起来像这样：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin12t.png
可以点击列标题来对这些进行排序--除了was_published_recently这个列，因为没有实现排序方法。
顺便看下这个列的标题was_published_recently，默认就是方法名（用空格代替下划线），该列的
每行都以字符串的形式展示出处。

可以通过该方法上（在polls/models.py中）使用display()装饰器来改进，如下所示：
'''
from django.contrib import admin
class Question(models.Model):
    @admin.display(
        boolean=True,
        ordering="pub_date",
        description="Published recently?",
    )
    def was_published_recently(self):
        now = timezone.now()
        return now - datetime.timedelta(days=1) <= self.pub_date <= now
'''
再次编辑文件polls/admin.py,优化Question变更页：过滤器，使用list_filter.将代码
添加至 QuestionAdmin：
'''
list_filter = ["pub_date"]
'''
这样做添加了一个过滤器的侧边栏，允许通过pub_date 字段来过滤列表：
https://docs.djangoproject.com/zh-hans/5.0/_images/admin13t.png
展示的过滤器类型取决于你要过滤的字段的类型。因为pub_date是类DateTimeField，
Django知道要提供哪个过滤器：“任意时间”，“今天”，“过去7天”，“这个月”和“今年”。

这已经完成了。让我们再扩充些功能：
'''
search_fields = ["question_text"]
'''
在列表的顶部增加一个搜索框。当输入待搜现项时，Django将搜索question_text字段。可以使用任意多的字段--
由于后台使用LIKE来查询数据，将待搜索的字段数限制为一个不会出问题大小，会便于数据库进行查询操作。

现在是给你的修改列表页增加分页功能的好时机。默认每页显示 100 项。变更页分页, 搜索框, 过滤器, 日期层次
结构, 和 列标题排序 均以你期望的方式合作运行。

#自定义后台界面和风格
在每个后台页顶部显示“Django管理员”显得很滑稽。这只是一串占位文本
可以通过Django的模板系统来修改。Django的后台由自己驱动，且它的交互接口采用Django自己的模板系统。

#自定义你的工程的模板
在你的工程目录（指包含manage.py的那个文件夹）内创建一个templates的目录。模板可放在你系统中任何Django
能找到的位置。（谁启动了Django，Django就以他的身份运行。）不过，把模板放在工程内会带来很大的便利。

打开设置文件（mysite/setting.py），在TEMPLATES设置中添加DIRS选项:
'''
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]
'''
DIRS是一个包含多个系统目录的文件列表，用于在载入Django模板时使用，是一个待搜索路径。

现在在templates目录中创建一个名为admin的目录，并将默认的Django管理界面模板目录中的模板文件
admin/base_site.html复制到该目录中。默认的Django管理界面模板位于Django的源码中（django/contrib/admin/templates）。

接着，用你网页站点的名字编辑替换文件内的 {{ site_header|default:_('Django administration') }} （包含大括号）。
完成后，你应该看到如下代码：
'''
{% block branding %}
<div id="site-name"><a href="{% url 'admin:index' %}">Polls Administration</a></div>
{% if user.is_anonymous %}
  {% include "admin/color_theme_toggle.html" %}
{% endif %}
{% endblock %}
'''
我们会用这个方法来教你复写模板。在一个实际工程中，你可能更期望使用 django.contrib.admin.AdminSite.site_header
来进行简单的定制。

这个模板文件包含很多类似 {% block branding %} 和 {{ title }} 的文本。 {% 和 {{ 标签是 Django 模板语言的一部分。
当 Django 渲染 admin/base_site.html 时，这个模板语言会被求值，生成最终的网页，就像我们在 教程第 3 部分 所学的一样。

注意，所有的 Django 默认后台模板均可被复写。若要复写模板，像你修改 base_site.html 一样修改其它文件——先将其从默认目录
中拷贝到你的自定义目录，再做修改。

#自定义你应用的模板
 DIRS 默认是空的，Django 是怎么找到默认的后台模板的？因为 APP_DIRS 被置为 True，Django 会自动在每个应用包内递归查找 
templates/ 子目录（不要忘了 django.contrib.admin 也是一个应用）。

我们的投票应用不是非常复杂，所以无需自定义后台模板。不过，如果它变的更加复杂，需要修改 Django 的标准后台模板功能时，修改
应用 的模板会比 工程 的更加明智。这样，在其它工程包含这个投票应用时，可以确保它总是能找到需要的自定义模板文件。

#自定义后台主页
默认情况下，它展示了所有配置在 INSTALLED_APPS 中，已通过后台应用注册，按拼音排序的应用。你可能想对这个页面的布局做重大的
修改。毕竟，索引页是后台的重要页面，它应该便于使用。

需要自定义的模板是 admin/index.html。（像上一节修改 admin/base_site.html 那样修改此文件——从默认目录中拷贝此文件至自定义
模板目录）。打开此文件，你将看到它使用了一个叫做 app_list 的模板变量。这个变量包含了每个安装的 Django 应用。你可以用任何
你期望的硬编码链接（链接至特定对象的管理页）替代使用这个变量。
