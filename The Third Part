#概况
Django中视图的概念是[一类具有相同功能和模板的网页的集合]。比如在一个博客应用中，你可能会创建以下几个视图：
博客首页--展示最近的几项内容
内容"详情"页--详细展示某项内容
以年为单位的归档页--展示选中的年份里各个月份创建的内容
以月为单位的归档页--展示选中的月份里各天创建的内容
以天为单位的归档页--展示选中天创建的所有内容
评论处理器--用于响应为一项内容添加评论的操作

在投票应用中，需要以下几个视图
问题索引页--展示最近的几个投票问题
问题详情页--展示某个投票的问题和不带结果的选项列表
问题结果页--展示某个投票的结果
投票处理器--用于响应用户为某个问题的特定选项投票的操作

在Django中，网页和其他内容都是由视图派生而来。每一个视图表现为一个Python函数（或者说是方法），Django将会根据
用户请求的URL来选择使用哪个视图（根据URL中域名之后的部分）

URL样式是URL的一般形式-例如：/newsarchive/<year>/<month>/
为了将URL和视图关联起来，Django使用了'URLconfs'来配置。URLconf将URL模式映射到视图

#编写更多的视图
向polls/views.py里添加更多的视图
'''
from django.http import HttpResponse, HttpResponseRedirect


def detail(request,question_id):
    return HttpResponse("You're looking at question %s!" % question_id)

def results(request,question_id):
    reposnses = "You're looking at the results of question %s."
    return HttpResponse(reposnses % question_id)
def vote(request,question_id):
    return HttpResponse("You're voting on question %s." % question_id)
'''
把这些新视图添加进polls.urls模块中，只要添加几个url()函数调用就行：
'''
from django.urls import path

from . import views

urlpatterns = [
    # ex: /polls/
    path("", views.index, name="index"),
    # ex: /polls/5/
    path("<int:question_id>/", views.detail, name="detail"),
    # ex: /polls/5/results/
    path("<int:question_id>/results/", views.results, name="results"),
    # ex: /polls/5/vote/
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
'''
在浏览器中查看"/polls/34/"。它将运行detail()函数并显示您在URL中提供的任何ID。也可以尝试
"/polls/34/results/" 和 "/polls/34/vote/"，这些将显示占位的结果和投票页面。

当有人请求你网站的页面，比如说，"/polls/34/"，Django会加载mysite.urls Python模块，因为它被
ROOT_URLCONF设置指向。它会找到名为urlpatterns的变量并按顺序遍历这些模式。在找到匹配项'polls/'
之后，它会剥离匹配的文本（"polls/"），然后将剩余的文本--"34/"--发送给'poslls.urls'URL配置以
进行进一步处理。在那里，它会匹配'<int:question_id>/',从而调用detail()视图
'''
detail(request=<HttpRequest object>, question_id=34)
'''
问题question_id=34来自<int:qusetion_id>。使用尖括号“获得”网址部分后发送给视图函数作为一个关键字参数。
字符串的question_id部分定义了要使用的名字，用来识别相匹配的模式，而int部分是一种转换形式，用来确定应该
匹配网址路径的什么模式。冒号（:）用来分隔转换形式和模式名。

#创建一个视图
每个视图必须要做的只有两件事：返回一个包含被请求页面内容的HttpReponse对象，或者抛出一个异常，比如Http404。

你的视图可以从数据库中读取记录，可以使用一个模板引擎，可以生成一个PDF文件，可以输出一个XML，创建一个ZIP文件，
可以做任何想做的事情，使用任何想使用的Python库。

Django只要求返回的是一个HttpReponse，或者抛出一个异常
'''
from django.http import HttpResponse

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    output=",".join(q.question_text for q in latest_question_list)
    return HttpResponse(output)
'''
这边存在的一个问题就是：页面的设计是写死在视图函数的代码里。如果想改变代码的样子，需要编辑Python代码。可以使用
Django的模板系统  ，只要创建一个视图，就可以将页面的设计从代码中分离出来。

首先，在polls目录中创建一个templates目录。Django将会在这个目录里查找模板文件。

项目的TEMPLATES配置项描述了Django如何载入和渲染模板。默认的设置文件设置了DjangoTemplates后端，并将APP_DIRS设置
成了True.这一选项将会让DjangoTemplates在每个INSTALLED_APPS文件夹中寻找"templates"子目录。这就是为什么没有像在
第二部分那样修改DIRS设置，Django也能正确找到polls的模板位置的原因。

在刚刚创建的templates目录里，再创建一个目录polls，然后在其中新建一个文件index.html。换句话说，模板文件的路径应该是
 polls/templates/polls/index.html 。因为"app_directories"模板加载器是通过上述描述的方法运行的，所以Django可以
引用到polls/index.html 这一模板了。

将下面的代码输入到刚刚创建的模板文件中：
'''
{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}
'''
此时更新一下 polls/views.py 里的 index 视图来使用模板：
'''
from django.http import HttpResponse
from django.template import loader

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    template = loader.get_template("polls/index.html")
    context = {
        "latest_question_list": latest_question_list,
    }
    return HttpResponse(template.render(context, request))
'''
上述代码的作用是，载入polls/index.html模板文件，并且向它传递一个上下文（context）。这上下文是一个字典，
它将模板内的变量映射为Python对象。

用浏览器访问"/polls/",将会看到一个无序列表，列出了在第二部分添加的 “What's up” 投票问题，链接指向这个投票的详情页。

#一个快捷函数：render()
[载入模板，填充上下文，再返回由它生成的HttpResponse对象]是一个非常常用的流程。
Django提供了一个快捷函数，我们用来重写index()视图:
'''
from django.shortcuts import render
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {"latest_question_list": latest_question_list}
    return render(request,"polls/index.html",context)

'''
我们不需要再导入loader和HttpReponse。如果还有其他的函数（比如说detail，result和vote）需要用到它的
话，就需要保持HttpResponse的导入

render()函数第一个参数是请求对象，第二个参数是模板名称，第三参数是一个可选的字典。他返回一个HttpResponse
对象，该对象包含使用给定的上下文渲染的指定模板

#抛出404错误
处理投票详情视图--会显示指定投票的问题标题。
'''
from django.http import Http404
from django.shortcuts import render

from .models import Question

def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    return render(render,"polls/detail.html",{"question":question})
'''
如果指定的问题ID所对应的问题不存在，这个视图会抛出一个404异常

尝试上面这个代码是否能够正常工作，在polls/detail.html输入
'''
{{ question }}
'''

#快捷函数 get_object_or_404()
尝试用get()函数获取一个对象，如果不存在就抛出Http404错误也是一个普遍的流程。Django也提供了一个快捷函数，
查看修改后的detail()视图代码：
'''
get_object_or_404()函数的第一个参数是Django模型，后面接受任意数量的关键字参数，这些参数会被传递给模型
管理器的get()函数。如果对象不存在，就会抛出Http404异常
也有get_list_or  _404()函数，工作原理和get_object_or_404()一样，除了get()函数被换成了filter()函数。
如果列表为空就会抛出Http404异常

#使用模板系统
看看detail()视图。向模板传递了上下文变量question。下面是polls/detail.html模板中正式的代码：
'''
<h1>{{ question.question_text }}</h1>
<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }}</li>
{% endfor %}
</ul>
'''
模板系统统一使用点符号来访问变量的属性。在示例{{question.question_text}}中，首先Django尝试对question对象
使用字典查找（也就是obj.get(str)操作），如果失败了就尝试属性查找（也就是obj.str操作），这一操作也失败的话，
将会尝试列表查找（也就是obj[int]操作）

在{% for %}循环中发生的函数调用：question.choice_set.all被解释为代码question.choice_set.all(),将会返回
一个可迭代的Choice对象，这一对象可以在{% for %}标签内部使用

#去除模板中的硬编码URL
在polls/index.html编写投票链接时，链接是硬编码的：
'''
<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
'''
这种硬编码、强耦合的方法的问题在于，在具有大量模板的项目中更改URL变得具有挑战性。然而，由于在polls.urls模块
中的path()函数中定义了name（）参数，可以通过使用{% url %}模板标签来消除url配置中定义的特定URL路径的依赖：
'''
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
'''
这个标签的工作方式是在polls.urls模块的URL定义中寻找具有指定名字的类目。可以回忆一下，具有名字'detail'的URL
是在如下语句中给定义的：
'''
# the 'name' value as called by the {% url %} template tag
path("<int:question_id>/", views.detail, name="detail"),
'''
如果想改变投票详情视图的URL，比如想改成polls/specifics/12/,你不用在模板中修改任何东西（包括其他模板），只要在
polls/urls.py里稍微修改一下就行
...
# added the word 'specifics'
path("specifics/<int:question_id>/", views.detail, name="detail"),
...

#为URL名称添加命名空间

问：polls应用有detail视图，可能另一个博客应用也有同名的视图。Django如何知道{% url %}标签到底对应哪一个
应用的URL呢？

答：在根URLconf中添加命名空间。在polls/urls.py文件中稍作修改，加上app_name设置命名空间：
'''
from django.urls import path

from . import views

app_name = "polls"
urlpatterns = [
    path("", views.index, name="index"),
    path("<int:question_id>/", views.detail, name="detail"),
    path("<int:question_id>/results/", views.results, name="results"),
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
'''
现在编辑polls/index.html文件，从：
'''
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
'''
修改为指向具有命名空间的详细视图：
'''
<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>
'''
